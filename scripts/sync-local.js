const { MongoClient } = require('mongodb');
const fs = require('fs').promises;
const path = require('path');
require('dotenv').config({ path: '.env.local' });

// MongoDB connection string from .env.local
const uri = process.env.MONGODB_URI;
if (!uri) {
  console.error('MONGODB_URI not found in .env.local');
  process.exit(1);
}

// Add debug logging
console.log('Using MongoDB URI:', uri.replace(/\/\/[^@]+@/, '//<credentials>@'));

function getStatusEmoji(status) {
  switch (status) {
    case 'Open': return 'ðŸ”´';
    case 'In Progress': return 'ðŸŸ¡';
    case 'Closed': return 'ðŸŸ¢';
  }
}

function formatReportsToMarkdown(reports) {
  // Calculate stats
  const activeCount = reports.filter(r => r.status === 'Open').length;
  const featureCount = reports.filter(r => r.type === 'feature' && r.status === 'Open').length;
  const completedCount = reports.filter(r => r.status === 'Closed').length;

  // Sort reports by status and date
  const openBugs = reports.filter(r => r.status === 'Open' && r.type === 'bug')
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  
  const openFeatures = reports.filter(r => r.status === 'Open' && r.type === 'feature')
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  
  const inProgressItems = reports.filter(r => r.status === 'In Progress')
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
  
  const recentlyClosed = reports.filter(r => r.status === 'Closed')
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
    .slice(0, 5); // Show only 5 most recent

  let content = `# Project Feedback Tracker

> Last Updated: ${new Date().toISOString()}
> This document is automatically synchronized with MongoDB. Manual edits will be overwritten.

## Quick Stats
ðŸ”„ Auto-generated from database
- ðŸ› Active Bugs: ${activeCount}
- âœ¨ Active Features: ${featureCount}
- âœ… Recently Completed: ${completedCount}

## Active Reports\n\n`;

  if (openBugs.length > 0) {
    content += '### Open Bugs\n\n';
    openBugs.forEach(bug => {
      content += formatReportToMarkdown(bug);
    });
  }

  if (openFeatures.length > 0) {
    content += '\n### Open Feature Requests\n\n';
    openFeatures.forEach(feature => {
      content += formatReportToMarkdown(feature);
    });
  }

  if (inProgressItems.length > 0) {
    content += '\n### In Progress\n\n';
    inProgressItems.forEach(item => {
      content += formatReportToMarkdown(item);
    });
  }

  if (recentlyClosed.length > 0) {
    content += '\n### Recently Completed\n\n';
    recentlyClosed.forEach(item => {
      content += formatReportToMarkdown(item);
    });
  }

  content += `\n## Guidelines

### Priority Levels

#### Bug Priority
- **High**: System-breaking issues affecting all users
- **Medium**: Functional issues affecting some users
- **Low**: Minor issues, cosmetic problems

#### Feature Priority
- **High**: Core functionality, immediate business value
- **Medium**: Important improvements, scheduled updates
- **Low**: Nice-to-have features, future considerations

### Status Definitions

#### Bug Status
- ðŸ”´ Open: Reported but not yet addressed
- ðŸŸ¡ In Progress: Currently being worked on
- ðŸŸ¢ Fixed: Resolution completed and verified

#### Feature Status
- ðŸ“‹ Planned: Approved but not started
- ðŸš§ Building: Currently in development
- âœ… Completed: Implemented and deployed

## Database Details

### Collections
- \`bugs\`: Bug reports and tracking
- \`features\`: Feature requests and planning

### Schema Overview
\`\`\`typescript
interface Report {
  _id: ObjectId;
  id: string;
  title: string;
  description: string;
  status: Status;
  priority: Priority;
  type: 'bug' | 'feature';
  reportedBy: string;
  steps?: string[];
  createdAt: Date;
  updatedAt: Date;
  resolvedBy?: string;
  notes?: string;
  screenshot?: {
    path: string;
    timestamp: Date;
  };
}
\`\`\`

## Templates

### Bug Report Template
\`\`\`markdown
#### [BUG-XX-###] Title
**Status**: ðŸ”´ Open/ðŸŸ¡ In Progress/ðŸŸ¢ Fixed
**Priority**: High/Medium/Low
**Description**: Clear description of the issue
**Steps to Reproduce**:
1. Step 1
2. Step 2
**Expected**: What should happen
**Actual**: What actually happens
\`\`\`

### Feature Request Template
\`\`\`markdown
#### [FEAT-XX-###] Title
**Status**: ðŸ“‹ Planned/ðŸš§ Building/âœ… Completed
**Priority**: High/Medium/Low
**Description**: Feature description
**Requirements**:
- [ ] Requirement 1
- [ ] Requirement 2
\`\`\`

---
> This file is automatically generated and synchronized with MongoDB.
> Last sync performed by local sync script.`;

  return content;
}

function formatReportToMarkdown(report) {
  const statusEmoji = getStatusEmoji(report.status);
  const typeEmoji = report.type === 'bug' ? 'ðŸ›' : 'âœ¨';
  
  let content = `#### [${report.id}] ${report.title}\n`;
  content += `**Status**: ${statusEmoji} ${report.status}\n`;
  content += `**Type**: ${typeEmoji} ${report.type === 'bug' ? 'Bug' : 'Feature'}\n`;
  content += `**Priority**: ${report.priority}\n`;
  content += `**Reported By**: ${report.reportedBy}\n`;
  content += `**Created**: ${new Date(report.createdAt).toLocaleString()}\n`;
  
  if (report.steps && report.steps.length > 0) {
    content += '**Steps to Reproduce**:\n';
    report.steps.forEach((step, index) => {
      content += `${index + 1}. ${step}\n`;
    });
  }

  if (report.status === 'Closed' && report.resolvedBy) {
    content += `**Resolved By**: ${report.resolvedBy}\n`;
  }

  if (report.notes) {
    content += `**Notes**: ${report.notes}\n`;
  }

  if (report.screenshot) {
    content += `**Screenshot**: [View](${report.screenshot.path})\n`;
  }

  content += '\n';
  return content;
}

async function syncFromDB() {
  const client = new MongoClient(uri);

  try {
    await client.connect();
    console.log('Connected to MongoDB');

    // Use Brain-Dump-Database
    const db = client.db('Brain-Dump-Database');
    console.log('Using database:', db.databaseName);

    const bugsCollection = db.collection('bugs');
    const featuresCollection = db.collection('features');

    // List all collections and their document counts
    const collections = await db.listCollections().toArray();
    console.log('\nCollections:');
    for (const collection of collections) {
      const count = await db.collection(collection.name).countDocuments();
      console.log(`- ${collection.name}: ${count} documents`);
    }

    // Fetch all reports
    const [bugs, features] = await Promise.all([
      bugsCollection.find({}).toArray(),
      featuresCollection.find({}).toArray()
    ]);

    console.log('\nBugs found:', bugs.map(b => ({ id: b.id, title: b.title })));
    console.log('Features found:', features.map(f => ({ id: f.id, title: f.title })));

    // Transform and combine reports
    const reports = [
      ...bugs.map(doc => ({ ...doc, type: 'bug' })),
      ...features.map(doc => ({ ...doc, type: 'feature' }))
    ];

    // Generate markdown
    const markdownContent = formatReportsToMarkdown(reports);

    // Write to file
    const filePath = path.join(process.cwd(), 'docs', 'FEEDBACK_TRACKER.md');
    await fs.writeFile(filePath, markdownContent, 'utf8');

    console.log('\nSuccessfully synced feedback tracker');

    // Optional: Commit changes
    const { execSync } = require('child_process');
    try {
      execSync('git add docs/FEEDBACK_TRACKER.md');
      execSync('git commit -m "chore: sync feedback tracker from database"');
      execSync('git push origin experimental');
      console.log('Changes committed and pushed to GitHub');
    } catch (error) {
      console.log('Note: No changes to commit or push');
    }

  } catch (error) {
    console.error('Error:', error);
  } finally {
    await client.close();
  }
}

async function updateBugStatus(bugId, newStatus, resolvedBy) {
  const client = new MongoClient(uri);

  try {
    await client.connect();
    console.log('Connected to MongoDB');

    // Use Brain-Dump-Database
    const db = client.db('Brain-Dump-Database');
    console.log('Using database:', db.databaseName);

    const bugsCollection = db.collection('bugs');
    const featuresCollection = db.collection('features');

    // Try to find the report in both collections
    let report = await bugsCollection.findOne({ id: bugId });
    let collection = bugsCollection;
    let type = 'bug';

    if (!report) {
      report = await featuresCollection.findOne({ id: bugId });
      collection = featuresCollection;
      type = 'feature';
    }

    if (!report) {
      console.error(`Report ${bugId} not found`);
      return;
    }

    // Update the report
    const updateData = {
      status: newStatus,
      updatedAt: new Date()
    };

    if (newStatus === 'Closed' && resolvedBy) {
      updateData.resolvedBy = resolvedBy;
    }

    await collection.updateOne(
      { id: bugId },
      { $set: updateData }
    );

    console.log(`Updated ${type} ${bugId} status to ${newStatus}`);

    // Sync the changes to markdown
    await syncFromDB();

  } catch (error) {
    console.error('Error:', error);
  } finally {
    await client.close();
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
const command = args[0];

if (!command) {
  console.log(`
Usage:
  node sync-local.js sync                               # Sync from DB to markdown
  node sync-local.js update <id> <status> [resolvedBy]  # Update bug/feature status
  
Examples:
  node sync-local.js sync
  node sync-local.js update BUG-001 Closed "John Doe"
  node sync-local.js update FEAT-001 "In Progress"
`);
  process.exit(1);
}

if (command === 'sync') {
  syncFromDB();
} else if (command === 'update') {
  const [id, status, resolvedBy] = args.slice(1);
  if (!id || !status) {
    console.error('Please provide both id and status');
    process.exit(1);
  }
  updateBugStatus(id, status, resolvedBy);
} else {
  console.error('Unknown command:', command);
  process.exit(1);
}
