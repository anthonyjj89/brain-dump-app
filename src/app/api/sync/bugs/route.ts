import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getCollection } from '@/lib/mongodb';
import { writeFile } from 'fs/promises';
import { join } from 'path';
import { Bug, generateBugId, validateBug, BUG_STATUSES, BUG_PRIORITIES } from '@/lib/schemas/bug';

function formatReportsToMarkdown(reports: Bug[]): string {
  // Sort reports by status, type, and then by creation date (newest first)
  const sortedReports = [...reports].sort((a, b) => {
    if (a.status !== b.status) {
      return a.status === 'Open' ? -1 : 1;
    }
    if (a.type !== b.type) {
      return a.type === 'bug' ? -1 : 1;
    }
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
  });

  const openBugs = sortedReports.filter(report => report.status === 'Open' && report.type === 'bug');
  const openFeatures = sortedReports.filter(report => report.status === 'Open' && report.type === 'feature');
  const closedReports = sortedReports.filter(report => report.status === 'Closed');

  let content = '# Bug and Feature Tracker\n\n';

  // Add timestamp
  content += `> Last Updated: ${new Date().toISOString()}\n\n`;

  // Open Bugs Section
  content += '## Open Bugs\n\n';
  openBugs.forEach(bug => {
    content += formatReportToMarkdown(bug);
  });

  // Open Features Section
  content += '\n## Open Feature Requests\n\n';
  openFeatures.forEach(feature => {
    content += formatReportToMarkdown(feature);
  });

  // Closed Reports Section
  content += '\n## Closed Reports\n\n';
  closedReports.forEach(report => {
    content += formatReportToMarkdown(report);
  });

  // Add footer
  content += '\n---\n';
  content += '> This file is automatically generated. Do not edit directly.\n';
  content += '> Last sync performed by the bug tracking system.\n';

  return content;
}

function formatReportToMarkdown(report: Bug): string {
  let content = `### [${report.id}] ${report.title}\n`;
  content += `- **Type**: ${report.type}\n`;
  content += `- **Status**: ${report.status}\n`;
  content += `- **Priority**: ${report.priority}\n`;
  content += `- **Reported By**: ${report.reportedBy}\n`;
  content += `- **Created**: ${report.createdAt.toISOString()}\n`;
  content += `- **Updated**: ${report.updatedAt.toISOString()}\n`;
  
  if (report.steps && report.steps.length > 0) {
    content += '- **Steps to Reproduce**:\n';
    report.steps.forEach((step, index) => {
      content += `  ${index + 1}. ${step}\n`;
    });
  }

  if (report.status === 'Closed' && report.resolvedBy) {
    content += `- **Resolved By**: ${report.resolvedBy}\n`;
  }

  if (report.notes) {
    content += `- **Notes**: ${report.notes}\n`;
  }

  if (report.screenshot) {
    content += `- **Screenshot**: [View](${report.screenshot})\n`;
  }

  content += '\n';
  return content;
}

export async function GET(request: NextRequest) {
  try {
    const collection = await getCollection('bugs');
    const reports = await collection.find<Bug>({}).sort({ 
      status: 1,
      type: 1,
      priority: -1,
      createdAt: -1
    }).toArray();

    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: 'Bug Tracker synced successfully',
      data: reports
    });
  } catch (error) {
    console.error('Error syncing bug tracker:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to sync Bug Tracker',
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const collection = await getCollection('bugs');

    if (!body.title || !body.priority || !body.reportedBy || !body.type) {
      return NextResponse.json({
        status: 'error',
        message: 'Missing required fields'
      }, { status: 400 });
    }

    const existingReport = await collection.findOne({
      title: body.title,
      status: 'Open',
      type: body.type
    });

    if (existingReport) {
      return NextResponse.json({
        status: 'error',
        message: `A similar open ${body.type} already exists`,
        data: existingReport
      }, { status: 409 });
    }

    const newReport: Bug = {
      id: generateBugId(),
      title: body.title,
      description: body.description,
      status: 'Open',
      priority: body.priority,
      reportedBy: body.reportedBy,
      steps: body.steps || [],
      type: body.type,
      createdAt: new Date(),
      updatedAt: new Date(),
      screenshot: body.screenshot || undefined
    };

    if (!validateBug(newReport)) {
      return NextResponse.json({
        status: 'error',
        message: 'Invalid bug report data'
      }, { status: 400 });
    }

    await collection.insertOne(newReport);

    const reports = await collection.find<Bug>({}).toArray();
    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: `${body.type.charAt(0).toUpperCase() + body.type.slice(1)} added and tracker synced`,
      data: newReport
    });
  } catch (error) {
    console.error('Error adding report:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to add report',
    }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const collection = await getCollection('bugs');

    if (!body.id) {
      return NextResponse.json({
        status: 'error',
        message: 'Report ID is required'
      }, { status: 400 });
    }

    const existingReport = await collection.findOne({ id: body.id });
    if (!existingReport) {
      return NextResponse.json({
        status: 'error',
        message: 'Report not found'
      }, { status: 404 });
    }

    const updateData: Partial<Bug> = {
      updatedAt: new Date()
    };

    if (body.status && BUG_STATUSES.includes(body.status)) updateData.status = body.status;
    if (body.priority && BUG_PRIORITIES.includes(body.priority)) updateData.priority = body.priority;
    if (body.resolvedBy) updateData.resolvedBy = body.resolvedBy;
    if (body.notes) updateData.notes = body.notes;
    if (body.screenshot) updateData.screenshot = body.screenshot;

    const updatedReport = { ...existingReport, ...updateData };
    if (!validateBug(updatedReport)) {
      return NextResponse.json({
        status: 'error',
        message: 'Invalid bug report data'
      }, { status: 400 });
    }

    const result = await collection.updateOne(
      { id: body.id },
      { $set: updateData }
    );

    if (result.matchedCount === 0) {
      return NextResponse.json({
        status: 'error',
        message: 'Report not found'
      }, { status: 404 });
    }

    const reports = await collection.find<Bug>({}).toArray();
    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: 'Report updated and tracker synced'
    });
  } catch (error) {
    console.error('Error updating report:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to update report',
    }, { status: 500 });
  }
}
