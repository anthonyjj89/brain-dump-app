import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getCollection } from '@/lib/mongodb';
import { writeFile } from 'fs/promises';
import { join } from 'path';
import { Bug, generateBugId, validateBug, BUG_STATUSES, BUG_PRIORITIES } from '@/lib/schemas/bug';

function formatReportsToMarkdown(reports: Bug[]): string {
  // Sort reports by status and creation date (newest first)
  const sortedReports = [...reports].sort((a, b) => {
    if (a.status !== b.status) {
      return a.status === 'Open' ? -1 : 1;
    }
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
  });

  const openReports = sortedReports.filter(report => report.status === 'Open');
  const closedReports = sortedReports.filter(report => report.status === 'Closed');

  let content = '# Bug and Feature Tracker\n\n';
  content += `> Last Updated: ${new Date().toISOString()}\n\n`;

  content += '## Open Reports\n\n';
  openReports.forEach(report => {
    content += formatReportToMarkdown(report);
  });

  content += '\n## Closed Reports\n\n';
  closedReports.forEach(report => {
    content += formatReportToMarkdown(report);
  });

  content += '\n---\n';
  content += '> This file is automatically generated. Do not edit directly.\n';
  content += '> Last sync performed by the bug tracking system.\n';

  return content;
}

function formatReportToMarkdown(report: Bug): string {
  let content = `### [${report.id}] ${report.title}\n`;
  content += `- **Type**: ${report.type}\n`;
  content += `- **Status**: ${report.status}\n`;
  content += `- **Priority**: ${report.priority}\n`;
  content += `- **Reported By**: ${report.reportedBy}\n`;
  content += `- **Created**: ${report.createdAt.toISOString()}\n`;
  content += `- **Updated**: ${report.updatedAt.toISOString()}\n`;
  
  if (report.steps && report.steps.length > 0) {
    content += '- **Steps to Reproduce**:\n';
    report.steps.forEach((step: string, index) => {
      content += `  ${index + 1}. ${step}\n`;
    });
  }

  if (report.status === 'Closed' && report.resolvedBy) {
    content += `- **Resolved By**: ${report.resolvedBy}\n`;
  }

  if (report.notes) {
    content += `- **Notes**: ${report.notes}\n`;
  }

  if (report.screenshot) {
    content += `- **Screenshot**: [View](${report.screenshot.path})\n`;
  }

  content += '\n';
  return content;
}

function transformToReport(doc: any, type: 'bug' | 'feature'): Bug {
  return {
    id: doc.id || generateBugId(),
    title: doc.title || '',
    description: doc.description || '',
    status: doc.status || 'Open',
    priority: doc.priority || 'Medium',
    type: type,
    reportedBy: doc.reportedBy || 'User',
    steps: doc.steps || [],
    createdAt: new Date(doc.createdAt || Date.now()),
    updatedAt: new Date(doc.updatedAt || Date.now()),
    resolvedBy: doc.resolvedBy,
    notes: doc.notes,
    screenshot: doc.screenshot ? {
      path: doc.screenshot.path,
      timestamp: new Date(doc.screenshot.timestamp)
    } : undefined
  };
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const type = (searchParams.get('type') || 'bug') as 'bug' | 'feature';
    const collectionName = type === 'feature' ? 'features' : 'bugs';
    
    console.log(`Fetching ${type} reports from ${collectionName} collection...`);
    const collection = await getCollection(collectionName);
    const docs = await collection.find({}).sort({ createdAt: -1 }).toArray();
    
    // Transform documents to match Bug type
    const reports = docs.map(doc => transformToReport(doc, type));
    console.log(`Found ${reports.length} ${type} reports`);

    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: `${type} reports synced successfully`,
      data: reports
    });
  } catch (error) {
    console.error('Error syncing reports:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to sync reports',
    }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Incoming report data:', body);

    // Determine collection based on report type
    const collectionName = body.type === 'feature' ? 'features' : 'bugs';
    const collection = await getCollection(collectionName);

    // Validate required fields
    const requiredFields = ['title', 'description', 'priority', 'type'];
    const missingFields = requiredFields.filter(field => !body[field]);
    if (missingFields.length > 0) {
      console.error('Missing required fields:', missingFields);
      return NextResponse.json({
        status: 'error',
        message: `Missing required fields: ${missingFields.join(', ')}`
      }, { status: 400 });
    }

    // Validate field types and formats
    if (typeof body.title !== 'string' || !body.title.trim()) {
      console.error('Invalid title');
      return NextResponse.json({
        status: 'error',
        message: 'Title must be a non-empty string'
      }, { status: 400 });
    }

    if (typeof body.description !== 'string' || !body.description.trim()) {
      console.error('Invalid description');
      return NextResponse.json({
        status: 'error',
        message: 'Description must be a non-empty string'
      }, { status: 400 });
    }

    if (!BUG_PRIORITIES.includes(body.priority)) {
      console.error('Invalid priority:', body.priority);
      return NextResponse.json({
        status: 'error',
        message: `Priority must be one of: ${BUG_PRIORITIES.join(', ')}`
      }, { status: 400 });
    }

    if (!['bug', 'feature'].includes(body.type)) {
      console.error('Invalid type:', body.type);
      return NextResponse.json({
        status: 'error',
        message: 'Type must be either "bug" or "feature"'
      }, { status: 400 });
    }

    if (body.steps && (!Array.isArray(body.steps) || body.steps.some((step: string) => typeof step !== 'string'))) {
      console.error('Invalid steps format');
      return NextResponse.json({
        status: 'error',
        message: 'Steps must be an array of strings'
      }, { status: 400 });
    }

    if (body.screenshot && (
      typeof body.screenshot !== 'object' ||
      typeof body.screenshot.path !== 'string' ||
      !(body.screenshot.timestamp instanceof Date || typeof body.screenshot.timestamp === 'string')
    )) {
      console.error('Invalid screenshot format');
      return NextResponse.json({
        status: 'error',
        message: 'Invalid screenshot format'
      }, { status: 400 });
    }

    const existingReport = await collection.findOne({
      title: body.title,
      status: 'Open'
    });

    if (existingReport) {
      console.log('Found existing report:', existingReport);
      return NextResponse.json({
        status: 'error',
        message: `A similar open ${body.type} already exists`,
        data: existingReport
      }, { status: 409 });
    }

    const newReport: Bug = {
      id: generateBugId(),
      title: body.title.trim(),
      description: body.description.trim(),
      status: 'Open',
      priority: body.priority,
      reportedBy: body.reportedBy || 'User',
      steps: (body.steps || []).filter((step: string) => step.trim() !== ''),
      type: body.type,
      createdAt: new Date(),
      updatedAt: new Date(),
      screenshot: body.screenshot ? {
        path: body.screenshot.path,
        timestamp: new Date(body.screenshot.timestamp)
      } : undefined
    };

    console.log('Validating new report:', newReport);
    if (!validateBug(newReport)) {
      console.error('Report validation failed');
      return NextResponse.json({
        status: 'error',
        message: 'Invalid report data'
      }, { status: 400 });
    }

    console.log(`Inserting new ${body.type} into ${collectionName} collection`);
    await collection.insertOne(newReport);

    // Update markdown file
    const docs = await collection.find({}).toArray();
    const reports = docs.map(doc => transformToReport(doc, body.type as 'bug' | 'feature'));
    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: `${body.type.charAt(0).toUpperCase() + body.type.slice(1)} added and tracker synced`,
      data: newReport
    });
  } catch (error) {
    console.error('Error adding report:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to add report',
    }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Incoming update data:', body);

    // Determine collection based on report type
    const collectionName = body.type === 'feature' ? 'features' : 'bugs';
    const collection = await getCollection(collectionName);

    if (!body.id) {
      console.error('Missing report ID');
      return NextResponse.json({
        status: 'error',
        message: 'Report ID is required'
      }, { status: 400 });
    }

    const existingReport = await collection.findOne({ id: body.id });
    if (!existingReport) {
      console.error('Report not found:', body.id);
      return NextResponse.json({
        status: 'error',
        message: 'Report not found'
      }, { status: 404 });
    }

    const updateData: Partial<Bug> = {
      updatedAt: new Date()
    };

    if (body.status && BUG_STATUSES.includes(body.status)) updateData.status = body.status;
    if (body.priority && BUG_PRIORITIES.includes(body.priority)) updateData.priority = body.priority;
    if (body.resolvedBy) updateData.resolvedBy = body.resolvedBy;
    if (body.notes) updateData.notes = body.notes;
    if (body.screenshot) updateData.screenshot = body.screenshot;

    console.log('Validating updated report');
    const updatedReport = { ...existingReport, ...updateData };
    if (!validateBug(updatedReport)) {
      console.error('Updated report validation failed');
      return NextResponse.json({
        status: 'error',
        message: 'Invalid report data'
      }, { status: 400 });
    }

    console.log('Updating report');
    const result = await collection.updateOne(
      { id: body.id },
      { $set: updateData }
    );

    if (result.matchedCount === 0) {
      console.error('No report matched for update');
      return NextResponse.json({
        status: 'error',
        message: 'Report not found'
      }, { status: 404 });
    }

    const docs = await collection.find({}).toArray();
    const reports = docs.map(doc => transformToReport(doc, body.type as 'bug' | 'feature'));
    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: 'Report updated and tracker synced'
    });
  } catch (error) {
    console.error('Error updating report:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to update report',
    }, { status: 500 });
  }
}
