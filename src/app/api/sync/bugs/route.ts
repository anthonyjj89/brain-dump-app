import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getCollection } from '@/lib/mongodb';
import { writeFile } from 'fs/promises';
import { join } from 'path';
import type { Bug } from '@/lib/schemas/bug';

function formatBugsToMarkdown(bugs: Bug[]): string {
  const openBugs = bugs.filter(bug => bug.status === 'Open');
  const closedBugs = bugs.filter(bug => bug.status === 'Closed');

  let content = '# Bug Tracker\n\n';

  // Add timestamp
  content += `> Last Updated: ${new Date().toISOString()}\n\n`;

  // Open Bugs Section
  content += '## Open Bugs\n\n';
  openBugs.forEach(bug => {
    content += formatBugToMarkdown(bug);
  });

  // Closed Bugs Section
  content += '\n## Closed Bugs\n\n';
  closedBugs.forEach(bug => {
    content += formatBugToMarkdown(bug);
  });

  // Add footer
  content += '\n---\n';
  content += '> This file is automatically generated. Do not edit directly.\n';
  content += '> Last sync performed by the bug tracking system.\n';

  return content;
}

function formatBugToMarkdown(bug: Bug): string {
  let content = `### [${bug.id}] ${bug.title}\n`;
  content += `- **Status**: ${bug.status}\n`;
  content += `- **Priority**: ${bug.priority}\n`;
  content += `- **Reported By**: ${bug.reportedBy}\n`;
  content += `- **Created**: ${bug.createdAt.toISOString()}\n`;
  content += `- **Updated**: ${bug.updatedAt.toISOString()}\n`;
  
  if (bug.steps.length > 0) {
    content += '- **Steps to Reproduce**:\n';
    bug.steps.forEach((step, index) => {
      content += `  ${index + 1}. ${step}\n`;
    });
  }

  if (bug.status === 'Closed' && bug.resolvedBy) {
    content += `- **Resolved By**: ${bug.resolvedBy}\n`;
  }

  if (bug.notes) {
    content += `- **Notes**: ${bug.notes}\n`;
  }

  content += '\n';
  return content;
}

export async function GET(request: NextRequest) {
  try {
    // Get bugs collection
    const collection = await getCollection('bugs');
    
    // Fetch all bugs
    const bugs = await collection.find<Bug>({}).sort({ 
      status: 1,  // Open bugs first
      priority: -1,  // High priority first
      createdAt: -1  // Newest first
    }).toArray();

    // Format bugs to markdown
    const markdownContent = formatBugsToMarkdown(bugs);

    // Write to BUG_TRACKER.md
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    // Return success response
    return NextResponse.json({
      status: 'success',
      message: 'Bug Tracker synced successfully',
      data: {
        totalBugs: bugs.length,
        openBugs: bugs.filter(b => b.status === 'Open').length,
        closedBugs: bugs.filter(b => b.status === 'Closed').length,
        lastUpdated: new Date().toISOString()
      }
    });
  } catch (error) {
    console.error('Error syncing bug tracker:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to sync Bug Tracker',
    }, { status: 500 });
  }
}

// Endpoint to manually add a bug
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const collection = await getCollection('bugs');

    // Validate bug data
    if (!body.title || !body.priority || !body.steps || !body.reportedBy) {
      return NextResponse.json({
        status: 'error',
        message: 'Missing required fields'
      }, { status: 400 });
    }

    const bug: Bug = {
      id: body.id || `BUG-${Date.now()}`,
      title: body.title,
      status: 'Open',
      priority: body.priority,
      reportedBy: body.reportedBy,
      steps: body.steps,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Insert bug
    await collection.insertOne(bug);

    // Trigger markdown sync
    const bugs = await collection.find<Bug>({}).toArray();
    const markdownContent = formatBugsToMarkdown(bugs);
    const filePath = join(process.cwd(), 'docs', 'BUG_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: 'Bug added and tracker synced',
      data: bug
    });
  } catch (error) {
    console.error('Error adding bug:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to add bug',
    }, { status: 500 });
  }
}
