import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getCollection } from '@/lib/mongodb';
import { writeFile } from 'fs/promises';
import { join } from 'path';
import { Bug, generateBugId, validateBug, BUG_STATUSES, BUG_PRIORITIES } from '@/lib/schemas/bug';

// Verify sync token for GitHub Actions
function isAuthorizedSync(request: NextRequest): boolean {
  const authHeader = request.headers.get('authorization');
  const syncToken = process.env.SYNC_TOKEN;
  
  // Skip auth check in development
  if (process.env.NODE_ENV === 'development') {
    return true;
  }

  if (!syncToken) {
    console.error('SYNC_TOKEN environment variable not set');
    return false;
  }

  return authHeader === `Bearer ${syncToken}`;
}

function getStatusEmoji(status: Bug['status']): string {
  switch (status) {
    case 'Open': return '🔴';
    case 'In Progress': return '🟡';
    case 'Closed': return '🟢';
  }
}

function formatReportsToMarkdown(reports: Bug[]): string {
  // Calculate stats
  const activeCount = reports.filter(r => r.status === 'Open').length;
  const featureCount = reports.filter(r => r.type === 'feature' && r.status === 'Open').length;
  const completedCount = reports.filter(r => r.status === 'Closed').length;

  // Sort reports by status and date
  const openBugs = reports.filter(r => r.status === 'Open' && r.type === 'bug')
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  
  const openFeatures = reports.filter(r => r.status === 'Open' && r.type === 'feature')
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  
  const inProgressItems = reports.filter(r => r.status === 'In Progress')
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
  
  const recentlyClosed = reports.filter(r => r.status === 'Closed')
    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime())
    .slice(0, 5); // Show only 5 most recent

  let content = `# Project Feedback Tracker

> Last Updated: ${new Date().toISOString()}
> This document is automatically synchronized with MongoDB. Manual edits will be overwritten.

## Quick Stats
🔄 Auto-generated from database
- 🐛 Active Bugs: ${activeCount}
- ✨ Active Features: ${featureCount}
- ✅ Recently Completed: ${completedCount}

## Active Reports\n\n`;

  if (openBugs.length > 0) {
    content += '### Open Bugs\n\n';
    openBugs.forEach(bug => {
      content += formatReportToMarkdown(bug);
    });
  }

  if (openFeatures.length > 0) {
    content += '\n### Open Feature Requests\n\n';
    openFeatures.forEach(feature => {
      content += formatReportToMarkdown(feature);
    });
  }

  if (inProgressItems.length > 0) {
    content += '\n### In Progress\n\n';
    inProgressItems.forEach(item => {
      content += formatReportToMarkdown(item);
    });
  }

  if (recentlyClosed.length > 0) {
    content += '\n### Recently Completed\n\n';
    recentlyClosed.forEach(item => {
      content += formatReportToMarkdown(item);
    });
  }

  // Add guidelines and templates
  content += `\n## Guidelines

### Priority Levels

#### Bug Priority
- **High**: System-breaking issues affecting all users
- **Medium**: Functional issues affecting some users
- **Low**: Minor issues, cosmetic problems

#### Feature Priority
- **High**: Core functionality, immediate business value
- **Medium**: Important improvements, scheduled updates
- **Low**: Nice-to-have features, future considerations

### Status Definitions

#### Bug Status
- 🔴 Open: Reported but not yet addressed
- 🟡 In Progress: Currently being worked on
- 🟢 Fixed: Resolution completed and verified

#### Feature Status
- 📋 Planned: Approved but not started
- 🚧 Building: Currently in development
- ✅ Completed: Implemented and deployed

## Database Schema

### Bug Report Schema
\`\`\`typescript
interface BugReport {
  id: string;
  title: string;
  type: 'bug';
  status: BugStatus;
  priority: Priority;
  description: string;
  steps: string[];
  expected: string;
  actual: string;
  impact: string;
  technical: string;
  notes: string;
  reported: Date;
  updated: Date;
  resolved?: Date;
  resolvedBy?: string;
}
\`\`\`

### Feature Request Schema
\`\`\`typescript
interface FeatureRequest {
  id: string;
  title: string;
  type: 'feature';
  status: FeatureStatus;
  priority: Priority;
  description: string;
  requirements: string[];
  dependencies: string[];
  technical: string;
  requested: Date;
  updated: Date;
  completed?: Date;
  implementedBy?: string;
}
\`\`\`

---
> This file is automatically generated and synchronized with MongoDB.
> Last sync performed by the feedback tracking system.`;

  return content;
}

function formatReportToMarkdown(report: Bug): string {
  const statusEmoji = getStatusEmoji(report.status);
  const typeEmoji = report.type === 'bug' ? '🐛' : '✨';
  
  let content = `#### [${report.id}] ${report.title}\n`;
  content += `**Status**: ${statusEmoji} ${report.status}\n`;
  content += `**Type**: ${typeEmoji} ${report.type === 'bug' ? 'Bug' : 'Feature'}\n`;
  content += `**Priority**: ${report.priority}\n`;
  content += `**Reported By**: ${report.reportedBy}\n`;
  content += `**Created**: ${new Date(report.createdAt).toLocaleString()}\n`;
  
  if (report.steps && report.steps.length > 0) {
    content += '**Steps to Reproduce**:\n';
    report.steps.forEach((step: string, index) => {
      content += `${index + 1}. ${step}\n`;
    });
  }

  if (report.status === 'Closed' && report.resolvedBy) {
    content += `**Resolved By**: ${report.resolvedBy}\n`;
  }

  if (report.notes) {
    content += `**Notes**: ${report.notes}\n`;
  }

  if (report.screenshot) {
    content += `**Screenshot**: [View](${report.screenshot.path})\n`;
  }

  content += '\n';
  return content;
}

export async function GET(request: NextRequest) {
  try {
    // Verify authorization for sync requests
    if (!isAuthorizedSync(request)) {
      return NextResponse.json({
        status: 'error',
        message: 'Unauthorized'
      }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const type = (searchParams.get('type') || 'bug') as 'bug' | 'feature';
    const collectionName = type === 'feature' ? 'features' : 'bugs';
    
    console.log(`Fetching ${type} reports from ${collectionName} collection...`);
    const collection = await getCollection(collectionName);
    const docs = await collection.find({}).sort({ createdAt: -1 }).toArray();
    
    // Transform documents to match Bug type
    const reports = docs.map(doc => transformToReport(doc, type));
    console.log(`Found ${reports.length} ${type} reports`);

    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'FEEDBACK_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: `${type} reports synced successfully`,
      data: reports
    });
  } catch (error) {
    console.error('Error syncing reports:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to sync reports',
    }, { status: 500 });
  }
}

function transformToReport(doc: any, type: 'bug' | 'feature'): Bug {
  return {
    id: doc.id || generateBugId(),
    title: doc.title || '',
    description: doc.description || '',
    status: doc.status || 'Open',
    priority: doc.priority || 'Medium',
    type: type,
    reportedBy: doc.reportedBy || 'User',
    steps: doc.steps || [],
    createdAt: new Date(doc.createdAt || Date.now()),
    updatedAt: new Date(doc.updatedAt || Date.now()),
    resolvedBy: doc.resolvedBy,
    notes: doc.notes,
    screenshot: doc.screenshot ? {
      path: doc.screenshot.path,
      timestamp: new Date(doc.screenshot.timestamp)
    } : undefined
  };
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Incoming report data:', body);

    // Determine collection based on report type
    const collectionName = body.type === 'feature' ? 'features' : 'bugs';
    const collection = await getCollection(collectionName);

    // Validate required fields
    const requiredFields = ['title', 'description', 'priority', 'type'];
    const missingFields = requiredFields.filter(field => !body[field]);
    if (missingFields.length > 0) {
      console.error('Missing required fields:', missingFields);
      return NextResponse.json({
        status: 'error',
        message: `Missing required fields: ${missingFields.join(', ')}`
      }, { status: 400 });
    }

    // Validate field types and formats
    if (typeof body.title !== 'string' || !body.title.trim()) {
      console.error('Invalid title');
      return NextResponse.json({
        status: 'error',
        message: 'Title must be a non-empty string'
      }, { status: 400 });
    }

    if (typeof body.description !== 'string' || !body.description.trim()) {
      console.error('Invalid description');
      return NextResponse.json({
        status: 'error',
        message: 'Description must be a non-empty string'
      }, { status: 400 });
    }

    if (!BUG_PRIORITIES.includes(body.priority)) {
      console.error('Invalid priority:', body.priority);
      return NextResponse.json({
        status: 'error',
        message: `Priority must be one of: ${BUG_PRIORITIES.join(', ')}`
      }, { status: 400 });
    }

    if (!['bug', 'feature'].includes(body.type)) {
      console.error('Invalid type:', body.type);
      return NextResponse.json({
        status: 'error',
        message: 'Type must be either "bug" or "feature"'
      }, { status: 400 });
    }

    if (body.steps && (!Array.isArray(body.steps) || body.steps.some((step: string) => typeof step !== 'string'))) {
      console.error('Invalid steps format');
      return NextResponse.json({
        status: 'error',
        message: 'Steps must be an array of strings'
      }, { status: 400 });
    }

    if (body.screenshot && (
      typeof body.screenshot !== 'object' ||
      typeof body.screenshot.path !== 'string' ||
      !(body.screenshot.timestamp instanceof Date || typeof body.screenshot.timestamp === 'string')
    )) {
      console.error('Invalid screenshot format');
      return NextResponse.json({
        status: 'error',
        message: 'Invalid screenshot format'
      }, { status: 400 });
    }

    const existingReport = await collection.findOne({
      title: body.title,
      status: 'Open'
    });

    if (existingReport) {
      console.log('Found existing report:', existingReport);
      return NextResponse.json({
        status: 'error',
        message: `A similar open ${body.type} already exists`,
        data: existingReport
      }, { status: 409 });
    }

    const newReport: Bug = {
      id: generateBugId(),
      title: body.title.trim(),
      description: body.description.trim(),
      status: 'Open',
      priority: body.priority,
      reportedBy: body.reportedBy || 'User',
      steps: (body.steps || []).filter((step: string) => step.trim() !== ''),
      type: body.type,
      createdAt: new Date(),
      updatedAt: new Date(),
      screenshot: body.screenshot ? {
        path: body.screenshot.path,
        timestamp: new Date(body.screenshot.timestamp)
      } : undefined
    };

    console.log('Validating new report:', newReport);
    if (!validateBug(newReport)) {
      console.error('Report validation failed');
      return NextResponse.json({
        status: 'error',
        message: 'Invalid report data'
      }, { status: 400 });
    }

    console.log(`Inserting new ${body.type} into ${collectionName} collection`);
    await collection.insertOne(newReport);

    // Update markdown file
    const docs = await collection.find({}).toArray();
    const reports = docs.map(doc => transformToReport(doc, body.type as 'bug' | 'feature'));
    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'FEEDBACK_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: `${body.type.charAt(0).toUpperCase() + body.type.slice(1)} added and tracker synced`,
      data: newReport
    });
  } catch (error) {
    console.error('Error adding report:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to add report',
    }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Incoming update data:', body);

    // Determine collection based on report type
    const collectionName = body.type === 'feature' ? 'features' : 'bugs';
    const collection = await getCollection(collectionName);

    if (!body.id) {
      console.error('Missing report ID');
      return NextResponse.json({
        status: 'error',
        message: 'Report ID is required'
      }, { status: 400 });
    }

    const existingReport = await collection.findOne({ id: body.id });
    if (!existingReport) {
      console.error('Report not found:', body.id);
      return NextResponse.json({
        status: 'error',
        message: 'Report not found'
      }, { status: 404 });
    }

    const updateData: Partial<Bug> = {
      updatedAt: new Date()
    };

    if (body.status && BUG_STATUSES.includes(body.status)) updateData.status = body.status;
    if (body.priority && BUG_PRIORITIES.includes(body.priority)) updateData.priority = body.priority;
    if (body.resolvedBy) updateData.resolvedBy = body.resolvedBy;
    if (body.notes) updateData.notes = body.notes;
    if (body.screenshot) updateData.screenshot = body.screenshot;

    console.log('Validating updated report');
    const updatedReport = { ...existingReport, ...updateData };
    if (!validateBug(updatedReport)) {
      console.error('Updated report validation failed');
      return NextResponse.json({
        status: 'error',
        message: 'Invalid report data'
      }, { status: 400 });
    }

    console.log('Updating report');
    const result = await collection.updateOne(
      { id: body.id },
      { $set: updateData }
    );

    if (result.matchedCount === 0) {
      console.error('No report matched for update');
      return NextResponse.json({
        status: 'error',
        message: 'Report not found'
      }, { status: 404 });
    }

    const docs = await collection.find({}).toArray();
    const reports = docs.map(doc => transformToReport(doc, body.type as 'bug' | 'feature'));
    const markdownContent = formatReportsToMarkdown(reports);
    const filePath = join(process.cwd(), 'docs', 'FEEDBACK_TRACKER.md');
    await writeFile(filePath, markdownContent, 'utf8');

    return NextResponse.json({
      status: 'success',
      message: 'Report updated and tracker synced'
    });
  } catch (error) {
    console.error('Error updating report:', error);
    return NextResponse.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Failed to update report',
    }, { status: 500 });
  }
}
